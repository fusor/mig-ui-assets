function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

export { default as selectable } from './decorators/selectable';
export { default as sortable } from './decorators/sortable';
export { default as cellActions } from './decorators/cellActions';
export { default as cellWidth } from './decorators/cellWidth';
export { default as textCenter } from './decorators/textCenter';
export { collapsible, expandedRow, expandable } from './decorators/collapsible';
export { compoundExpand } from './decorators/compoundExpand';
export { default as headerCol } from './decorators/headerCol';
export { default as classNames, Visibility } from './decorators/classNames';
export const emptyTD = () => ({
  scope: '',
  component: 'td'
});
export const scopeColTransformer = () => ({
  scope: 'col'
});
export const emptyCol = label => _objectSpread({}, label ? {} : {
  scope: ''
});
export const parentId = (_value, {
  rowData
}) => ({
  parentId: rowData.parent
});
export const mapProps = (_label, {
  property,
  rowData
}) => _objectSpread({}, rowData[property] && rowData[property].props);
//# sourceMappingURL=transformers.js.map