(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["exports", "prop-types", "react", "@tippy.js/react", "../../helpers/constants", "@patternfly/react-styles/css/components/Popover/popover", "@patternfly/react-styles", "./PopoverArrow", "./PopoverContent", "./PopoverBody", "./PopoverHeader", "./PopoverFooter", "./PopoverCloseButton", "../../helpers/GenerateId/GenerateId", "@patternfly/react-tokens", "../Tooltip/styles", 'focus-trap-react'], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports, require("prop-types"), require("react"), require("@tippy.js/react"), require("../../helpers/constants"), require("@patternfly/react-styles/css/components/Popover/popover"), require("@patternfly/react-styles"), require("./PopoverArrow"), require("./PopoverContent"), require("./PopoverBody"), require("./PopoverHeader"), require("./PopoverFooter"), require("./PopoverCloseButton"), require("../../helpers/GenerateId/GenerateId"), require("@patternfly/react-tokens"), require("../Tooltip/styles"), require('focus-trap-react'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports, global.propTypes, global.react, global.react, global.constants, global.popover, global.reactStyles, global.PopoverArrow, global.PopoverContent, global.PopoverBody, global.PopoverHeader, global.PopoverFooter, global.PopoverCloseButton, global.GenerateId, global.reactTokens, global.styles, global.focusTrapReact);
    global.undefined = mod.exports;
  }
})(this, function (exports, _propTypes, _react, _react2, _constants, _popover, _reactStyles, _PopoverArrow, _PopoverContent, _PopoverBody, _PopoverHeader, _PopoverFooter, _PopoverCloseButton, _GenerateId, _reactTokens, _styles, FocusTrap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Popover = exports.PopoverPosition = undefined;

  var _propTypes2 = _interopRequireDefault(_propTypes);

  var React = _interopRequireWildcard(_react);

  var _react3 = _interopRequireDefault(_react2);

  var _popover2 = _interopRequireDefault(_popover);

  var _GenerateId2 = _interopRequireDefault(_GenerateId);

  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};

      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};

            if (desc.get || desc.set) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
      }

      newObj.default = obj;
      return newObj;
    }
  }

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};

    var target = _objectWithoutPropertiesLoose(source, excluded);

    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  (0, _styles.tippyStyles)();
  let PopoverPosition = exports.PopoverPosition = undefined;

  (function (PopoverPosition) {
    PopoverPosition["top"] = "top";
    PopoverPosition["bottom"] = "bottom";
    PopoverPosition["left"] = "left";
    PopoverPosition["right"] = "right";
  })(PopoverPosition || (exports.PopoverPosition = PopoverPosition = {}));

  ;

  class Popover extends React.Component {
    constructor(props) {
      super(props);

      _defineProperty(this, "hideOrNotify", () => {
        if (this.props.isVisible === null) {
          // Handle closing
          this.tip.hide();
        } else {
          // notify consumer
          this.props.shouldClose(this.tip);
        }
      });

      _defineProperty(this, "handleEscKeyClick", event => {
        if (event.keyCode === _constants.KEY_CODES.ESCAPE_KEY && this.tip.state.isVisible) {
          this.hideOrNotify();
        }
      });

      _defineProperty(this, "storeTippyInstance", tip => {
        this.tip = tip;
      });

      _defineProperty(this, "closePopover", () => {
        this.hideOrNotify();
      });

      _defineProperty(this, "hideAllPopovers", () => {
        document.querySelectorAll('.tippy-popper').forEach(popper => {
          if (popper._tippy) {
            popper._tippy.hide();
          }
        });
      });

      _defineProperty(this, "onHide", tip => {
        if (this.state.isOpen) {
          this.setState({
            isOpen: false
          });
        }

        return this.props.onHide(tip);
      });

      _defineProperty(this, "onHidden", tip => this.props.onHidden(tip));

      _defineProperty(this, "onMount", tip => this.props.onMount(tip));

      _defineProperty(this, "onShow", tip => {
        const {
          hideOnOutsideClick,
          isVisible,
          onShow
        } = this.props; // hide all other open popovers first if events are managed by us

        if (!hideOnOutsideClick && isVisible === null) {
          this.hideAllPopovers();
        }

        if (this.state.isOpen === false) {
          this.setState({
            isOpen: true
          });
        }

        return onShow(tip);
      });

      _defineProperty(this, "onShown", tip => this.props.onShown(tip));

      this.state = {
        isOpen: false
      };
    }

    componentDidMount() {
      document.addEventListener('keydown', this.handleEscKeyClick, false);
    }

    componentWillUnmount() {
      document.removeEventListener('keydown', this.handleEscKeyClick, false);
    }

    render() {
      const _this$props = this.props,
            {
        position,
        enableFlip,
        children,
        className,
        'aria-label': ariaLabel,
        headerContent,
        bodyContent,
        footerContent,
        isVisible,
        shouldClose,
        appendTo,
        hideOnOutsideClick,
        onHide,
        onHidden,
        onShow,
        onShown,
        onMount,
        zIndex,
        maxWidth,
        closeBtnAriaLabel
      } = _this$props,
            rest = _objectWithoutProperties(_this$props, ["position", "enableFlip", "children", "className", "aria-label", "headerContent", "bodyContent", "footerContent", "isVisible", "shouldClose", "appendTo", "hideOnOutsideClick", "onHide", "onHidden", "onShow", "onShown", "onMount", "zIndex", "maxWidth", "closeBtnAriaLabel"]);

      if (!headerContent && !ariaLabel) {
        return new Error('aria-label is required when header is not used');
      }

      const content = React.createElement(_GenerateId2.default, null, randomId => this.state.isOpen && React.createElement(FocusTrap, {
        focusTrapOptions: {
          clickOutsideDeactivates: true
        }
      }, React.createElement("div", _extends({
        className: (0, _reactStyles.css)(_popover2.default.popover, !enableFlip && (0, _reactStyles.getModifier)(_popover2.default, position, _popover2.default.modifiers.top), className),
        role: "dialog",
        "aria-modal": "true",
        "aria-label": headerContent ? undefined : ariaLabel,
        "aria-labelledby": headerContent ? `popover-${randomId}-header` : undefined,
        "aria-describedby": `popover-${randomId}-body`
      }, rest), React.createElement(_PopoverArrow.PopoverArrow, null), React.createElement(_PopoverContent.PopoverContent, null, React.createElement(_PopoverCloseButton.PopoverCloseButton, {
        onClose: this.closePopover,
        "aria-label": closeBtnAriaLabel
      }), headerContent && React.createElement(_PopoverHeader.PopoverHeader, {
        id: `popover-${randomId}-header`
      }, headerContent), React.createElement(_PopoverBody.PopoverBody, {
        id: `popover-${randomId}-body`
      }, bodyContent), footerContent && React.createElement(_PopoverFooter.PopoverFooter, null, footerContent)))));
      const handleEvents = isVisible === null;

      const shouldHideOnClick = () => {
        if (handleEvents) {
          if (hideOnOutsideClick === true) {
            return true;
          }

          return 'toggle';
        }

        return false;
      };

      return React.createElement(_react3.default, {
        onCreate: this.storeTippyInstance,
        maxWidth: maxWidth,
        zIndex: zIndex,
        appendTo: appendTo,
        content: content,
        lazy: true,
        trigger: handleEvents ? 'click' : 'manual',
        isVisible: isVisible,
        hideOnClick: shouldHideOnClick(),
        animateFill: false,
        theme: "pf-tippy",
        performance: true,
        interactive: true,
        interactiveBorder: 0,
        placement: position,
        distance: 25,
        flip: enableFlip,
        popperOptions: {
          modifiers: {
            preventOverflow: {
              enabled: enableFlip
            },
            hide: {
              enabled: enableFlip
            }
          }
        },
        onHide: this.onHide,
        onHidden: this.onHidden,
        onShow: this.onShow,
        onShown: this.onShown,
        onMount: this.onMount
      }, children);
    }

  }

  exports.Popover = Popover;

  _defineProperty(Popover, "propTypes", {
    position: _propTypes2.default.oneOf(['top', 'bottom', 'left', 'right']),
    enableFlip: _propTypes2.default.bool,
    className: _propTypes2.default.string,
    children: _propTypes2.default.element.isRequired,
    'aria-label': _propTypes2.default.string,
    headerContent: _propTypes2.default.node,
    bodyContent: _propTypes2.default.node.isRequired,
    footerContent: _propTypes2.default.node,
    isVisible: _propTypes2.default.bool,
    shouldClose: _propTypes2.default.func,
    appendTo: _propTypes2.default.oneOfType([_propTypes2.default.element, _propTypes2.default.func]),
    hideOnOutsideClick: _propTypes2.default.bool,
    onHide: _propTypes2.default.func,
    onHidden: _propTypes2.default.func,
    onShow: _propTypes2.default.func,
    onShown: _propTypes2.default.func,
    onMount: _propTypes2.default.func,
    zIndex: _propTypes2.default.number,
    maxWidth: _propTypes2.default.string,
    closeBtnAriaLabel: _propTypes2.default.string
  });

  _defineProperty(Popover, "defaultProps", {
    position: 'top',
    enableFlip: true,
    className: '',
    isVisible: null,
    shouldClose: () => null,
    'aria-label': '',
    headerContent: null,
    footerContent: null,
    appendTo: () => document.body,
    hideOnOutsideClick: true,
    onHide: () => null,
    onHidden: () => null,
    onShow: () => null,
    onShown: () => null,
    onMount: () => null,
    zIndex: 9999,
    maxWidth: _reactTokens.c_popover_MaxWidth && _reactTokens.c_popover_MaxWidth.value,
    closeBtnAriaLabel: 'Close'
  });
});
//# sourceMappingURL=Popover.js.map